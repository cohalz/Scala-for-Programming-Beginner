#List入門2
##Listの構造
前回ではListを変数の集まりとして導入しました。  
今回はList自体についてもう少し掘り下げていきます。

まずはじめに、別の方法でListを作っていきます。  
**Sublime Text 2**で**7.scala**という名前で以下のコードを保存してください。

```scala
println(1 :: 2 :: 3 :: List())
```

実行します。

```
scala 7.scala
```

```
List(1, 2, 3)
```

1と2と3が順に入ったListが作れています。  
何故```1 :: 2 :: 3 :: List()```と書いてListが作れるのか順番に見て行きましょう。

まずは```::```について解説していきます。  
左側に追加したい要素、真ん中に```::```、右側に追加されるListを書くと、  
左側の要素を先頭に追加したListを作ります。

例を見てみます。
```scala
println(3 :: List(2,1))
```
以下のように出力されます。
```
List(3, 2, 1)
```

このように3が先頭に追加されたListが表示されています。  
ですが、さっきは

```scala
1 :: 2 :: 3 :: List()
```

と、```1 :: 2```と書きました。2はListではないのに何故でしょう？

実は```::```は複数ある場合、**右側から追加**されていきます。  
以下の例を見てみましょう。
```scala
5 :: 4 :: List(3, 2, 1)
```

右側から追加されるので、以下の様な順番で書き換えられます。  
まず```4 :: List(3, 2, 1)```が評価されます。

```scala
5 :: List(4, 3, 2, 1)
```

その次に```5 :: List(4, 3, 2, 1)```が評価されます。

```scala
List(5, 4, 3, 2, 1)
```

なので```1 :: 2 :: 3 :: List()```の優先順位をカッコでわかりやすくすると、以下のようになります。

```scala
1 :: (2 :: (3 :: List()))
```

List()に3が追加され、更に2が追加され、1が追加されるというわけです。

では```List()```とは何なのでしょう？  
これは**空List**と言って、見た目の通り、何も中身が無いListを表します。

```3 :: List()```がどうなるのか見てみましょう。
```scala
println(3 :: List())
```
```
List(3)
```
何もないListに3が追加され、結果3が入ったListになるというわけです。  
List()は**Nil**と書いても同じ意味を表します。

Listは「空List」か「先頭要素と残りのList」として定義されています。  
この様に「AはAである」のような構造を**再帰的**といいますが、  
Listがこのように再帰的な構造をしていることはプログラムでは**とても重要**です。  
再帰構造については、詳しくは後々紹介していきます。  

##List自体は変更されない
大事なのが、このようなメソッドでList自体が**変更されるわけではない**ということです。  
例を見てみます。
```scala
val list = List(1, 2)
println(3 :: list) // List(3, 1, 2) 
println(list) // List(1, 2)のまま
```
追加されたものが新たに作られるだけなので書き換えが起こっているわけではありません。  
注意しましょう。

##Listの便利なメソッド
前回はsum、length、fillを紹介しました。  
もう少しListのメソッドを紹介していきます。

- **:::** / **++**   
  二つのListを連結します。
  ++も同じ動作をします。
  ```scala
  List(1, 2, 3) ::: List(4, 5) // List(1, 2, 3, 4, 5)が作られます。
  List(1, 2, 3) ++ List(4, 5)  // List(1, 2, 3, 4, 5)
  ```  

- **take** / **takeRight**  
  数字を指定して、端からその数字分だけの個数抜き出したListを作ります。  
  takeは左から、takeRightは右から抜き出します。
  ```scala
  List(1, 2, 3, 4, 5).take(2)      // 左から2個抜き出され、List(1,2)となります。
  List(1, 2, 3, 4, 5).takeRight(2) // 右から2個抜き出され、List(4,5)となります。
  ```

- **drop** / **dropRight**  
  takeとは逆に、数字分の個数だけ除いたListを作ります。
  ```scala
  List(1, 2, 3, 4, 5).drop(2)     // List(3, 4, 5)
  List(1, 2, 3, 4, 5).dropRight(2) // List(1, 2, 3)
  ```

- **contains**  
  指定した要素が、Listに含まれているかどうかを判定します。  
  ifの中で使うことが出来ます。
  ```scala
  val list = List(1, 2, 3)
  if(list.contains(2)) {
    println("list contains 2") // listに2が含まれていたら実行されます
  } else {
    println("list doesn't contains 2") // 含まれていない時のみ実行されます。
  }
  ```

- **filter**  
  Listの中で条件を満たしている要素だけで出来たListを作ります。  
  各要素を_(アンダーバー)で扱い、判定します。  
  以下のコードは偶数だけ抜き出すことが出来ます。
  ```scala
  List(1, 2, 3, 4, 5).filter(_ % 2 == 0) // List(2, 4)が作られます。
  ```

- **map**  
  Listの中のすべての要素を、指定した計算をした結果に置き換えます。  
  各要素を_で扱います。  
  以下のコードは、すべての要素を3で割った余りに置き換えます。
  ```scala
  List(1, 2, 3, 4, 5).map(_ % 3) // List(1, 2, 0, 1, 2)が作られます。
  ```

##各要素を変数で扱う
filterやmapでは各要素をアンダーバーで扱いました。  
アンダーバーではなく、forで使ったiのような変数を中で使うことが出来ます。  
使いたい**変数と=>を書いて**その後に実行したいものを書きます。  
以下のコードでは各要素がxで扱うことが出来るようになります。  
forの時のiのように、xはその**前に書いてある変数ではない**ことを注意してください。
```scala
List(1, 2, 3, 4, 5).filter(x => x % 2 == 0) // List(2, 4)が作られます。
```

では短いアンダーバーじゃなく変数を使う意味は何でしょう？  
実は要素をアンダーバーを使って取り出す場合、**一度しか使えません**。  
例えば、各要素を二乗したものに置き換えたListを作りたい場合、アンダーバーでは出来ません。

```scala
List(1, 2, 3, 4).map(x => x * x) // List(1, 4, 9, 25)
List(1, 2, 3, 4).map(_ * _) // 一度しか使えないので、このようには書けません。エラーが発生します。
```

また、mapの中でも、ifを使うことが出来ます。  
以下のコードは、7より小さい数だけを二倍したListを作ります。
```scala
List(5, 6, 7, 8).map(x => if(x < 7) 2 * x else x) // List(10, 12, 7, 8)が作られます。
```

##toやuntilの実態
forで使ったtoやuntilは実際にはListとよく似た**Range**というものが作られています。  
正確には、Listではありませんが、後に**toListと書く**ことでListに変更し、  
上で書いたメソッドを使う事が可能です。  
連続した数字を使いたいときに便利です。

```scala
println((1 to 5).toList) // List(1, 2, 3, 4, 5)
```
```scala
(1 to 6).toList.filter(_ % 2 == 0) // List(2, 4, 6)が作られます。
```
##練習用課題
練習として**7.scala**に以下のコードを書いてみてください。  

###(1)
最初に数字nを入力し、次にfillを使ってn個の整数が入ったListを作ります。  
Listの中に最初に入力した数字nがあればYES、  
そうでなければNOを出力するプログラムを書いてください。
####入力例1：
```
3
1
2
3
```
####出力例1：
```
YES
```
List(1, 2, 3)の中には3が入っています。
####入力例2：
```
5
3
4
6
7
8
```
####出力例2：
```
NO
```
5は入っていません。

###(2)
最初に数字nを入力し、1からnまでの数字を合計した数字を出力してください。
####入力例1：

```
5
```

####出力例1：

```
15
```
1から5までの合計は15です。
####入力例2：

```
100
```

####出力例2：

```
5050
```

###(3)
最初に数字nを入力し、1からnまでの数字の二乗を合計した数字を出力してください。
####入力例1：

```
5
```
####出力例1：

```
55
```
1 + 4 + 9 + 16 + 25 = 55となります。
####入力例2：

```
100
```

####出力例2：

```
338350
```


###提出方法
[こちら](https://github.com/cohalz/Scala-for-Programming-Beginner/issues/new)を用意しました。  
はじめにGitHubアカウントを作成してください。  
アカウントを作成できたら、ログインをして、上記のページに飛びます。  
Titleに「07-1」など、いつの何番の問題かわかるように書いてください。  
Leave a commentに書いたコードを貼り付けて、Submit new issueを押してください。   
課題が提出できたら、しばらくして僕が評価を返すのでそれを待ちましょう。  

もしちょっと考えてわからなかったら上部にあるanswerに答えを用意しましたので、ぜひ活用してください。

また質問やご意見あればお待ちしてます。  
上記のページは課題以外でも質問やご意見を送ることができます。  
[こちら](https://github.com/cohalz/Scala-for-Programming-Beginner/issues/new)かTwitter([@cohalz](https://twitter.com/cohalz))まで気軽にどうぞ。是非一緒に学びましょう。

次回 -> [型](https://github.com/cohalz/Scala-for-Programming-Beginner/tree/master/08)

前回 -> [List入門](https://github.com/cohalz/Scala-for-Programming-Beginner/tree/master/06)
